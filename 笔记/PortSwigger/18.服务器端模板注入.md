# 服务器端模板注入

服务器端模板注入是指攻击者能够使用本机模板语法将恶意负载注入模板，然后在服务器端执行。

模板引擎旨在通过将固定模板与易失数据相结合来生成网页。当用户输入直接连接到模板中而不是作为数据传入时，可能会发生服务器端模板注入攻击。这允许攻击者注入任意模板指令以操纵模板引擎，通常使他们能够完全控制服务器。顾名思义，服务器端模板注入有效负载是在服务器端交付和评估的，这可能使它们比典型的客户端模板注入更危险。


## 服务器端模板注入有什么影响？

服务器端模板注入漏洞可能会使网站遭受各种攻击，具体取决于相关模板引擎以及应用程序如何使用它。在某些极少数情况下，这些漏洞不会构成真正的安全风险。然而，大多数时候，服务器端模板注入的影响可能是灾难性的。

在规模严重的一端，攻击者可能实现远程代码执行，完全控制后端服务器并使用它对内部基础设施执行其他攻击。

即使在无法完全远程执行代码的情况下，攻击者通常仍然可以使用服务器端模板注入作为众多其他攻击的基础，从而可能获得对服务器上敏感数据和任意文件的读取访问权限。

## 服务器端模板注入漏洞是如何产生的？

当用户输入连接到模板中而不是作为数据传入时，服务器端模板注入漏洞就会出现。

静态模板只是提供了呈现动态内容的占位符，通常不易受到服务器端模板注入的攻击。典型的例子是一封电子邮件，它以每个用户的名字打招呼，例如以下来自 Twig 模板的摘录：

`$output = $twig->render("Dear {first_name},", array("first_name" => $user.first_name) );`

这不容易受到服务器端模板注入的影响，因为用户的名字只是作为数据传递到模板中。

然而，由于模板只是字符串，Web 开发人员有时会在渲染之前直接将用户输入连接到模板中。让我们以与上述类似的示例为例，但这一次，用户可以在发送电子邮件之前自定义部分电子邮件。例如，他们可能能够选择使用的名称：

`$output = $twig->render("Dear " . $_GET['name']);`

`GET`在此示例中，不是将静态值传递给模板，而是使用参数 动态生成模板本身的一部分`name`。由于模板语法是在服务器端评估的，这可能允许攻击者将服务器端模板注入有效负载放置在`name`参数中，如下所示：

`http://vulnerable-website.com/?name={{bad-stuff-here}}`

像这样的漏洞有时是由于不熟悉安全隐患的人的不良模板设计而造成的。与上面的示例一样，您可能会看到不同的组件，其中一些包含用户输入、连接并嵌入到模板中。在某些方面，这类似于编写不佳的准备语句中发生的 [SQL 注入漏洞。](https://portswigger.net/web-security/sql-injection)

但是，有时这种行为实际上是有意实现的。例如，某些网站故意允许某些特权用户（例如内容编辑者）通过设计编辑或提交自定义模板。如果攻击者能够破坏具有此类权限的帐户，这显然会带来巨大的安全风险。

## 构建服务器端模板注入攻击

识别服务器端模板注入漏洞并制定成功的攻击通常涉及以下高级流程。
![[ssti-methodology-diagram.png]]

### 探测

服务器端模板注入漏洞经常被忽视，不是因为它们很复杂，而是因为它们只对明确寻找它们的审计人员才真正明显。如果您能够检测到存在漏洞，那么利用它可能会非常容易。在非沙盒环境中尤其如此。

与任何漏洞一样，利用的第一步是能够找到它。也许最简单的初始方法是通过注入模板表达式中常用的一系列特殊字符来尝试对模板进行模糊测试，例如`${{<%[%'"}}%\`. 如果引发异常，则表明注入的模板语法可能被服务器以某种方式解释。这是服务器端模板注入漏洞可能存在的一个迹象。

服务器端模板注入漏洞发生在两个不同的上下文中，每个上下文都需要自己的检测方法。无论您的 fuzzing 尝试的结果如何，尝试以下特定于上下文的方法也很重要。如果模糊测试没有定论，漏洞可能仍会使用其中一种方法暴露出来。即使 fuzzing 确实暗示了模板注入漏洞，您仍然需要识别其上下文才能利用它。

#### 明文上下文

大多数模板语言允许您通过直接使用 HTML 标记或使用模板的本机语法自由输入内容，在发送 HTTP 响应之前，这些语法将在后端呈现为 HTML。例如，在 Freemarker 中，该行将 `render('Hello ' + username)`呈现为web-security/cross-site-scripting)，实际上经常被误认为是一个简单的 XSS 漏洞。但是，通过将数学运算设置为参数的值，我们可以测试这是否也是服务器端模板注入攻击的潜在切入点。

例如，考虑一个包含以下易受攻击代码的模板：

`render('Hello ' + username)`

在审核期间，我们可能会通过请求 URL 来测试服务器端模板注入，例如：

`http://vulnerable-website.com/?username=${7*7}`

如果结果输出包含`Hello 49`，这表明数学运算正在服务器端进行评估。这是服务器端模板注入漏洞的一个很好的概念证明。

请注意，成功评估数学运算所需的特定语法将根据所使用的模板引擎而有所不同。我们将在[识别](https://portswigger.net/web-security/server-side-template-injection#identify)步骤中更详细地讨论这一点。

#### 代码上下文

在其他情况下，漏洞是通过将用户输入放置在模板表达式中来暴露的，正如我们之前在电子邮件示例中看到的那样。这可能采用将用户可控变量名称放置在参数中的形式，例如：

`greeting = getQueryParameter('greeting') engine.render("Hello {{"+greeting+"}}", data)`

在网站上，生成的 URL 将类似于：

`http://vulnerable-website.com/?greeting=data.username`

例如，这将在输出中呈现`Hello Carlos`。

在评估过程中很容易忽略此上下文，因为它不会导致明显的 XSS，并且与简单的 hashmap 查找几乎无法区分。在此上下文中测试服务器端模板注入的一种方法是首先通过将任意 HTML 注入值来确定该参数不包含直接 XSS 漏洞：

`http://vulnerable-website.com/?greeting=data.username<tag>`

在没有 XSS 的情况下，这通常会导致输出中出现空白条目（只是`Hello`没有用户名）、编码标签或错误消息。下一步是尝试使用通用模板语法打破语句，并尝试在其后注入任意 HTML：

`http://vulnerable-website.com/?greeting=data.username}}<tag>`

如果这再次导致错误或空白输出，则您使用了来自错误模板语言的语法，或者，如果没有模板样式的语法似乎是有效的，则服务器端模板注入是不可能的。或者，如果正确呈现输出以及任意 HTML，则这是存在服务器端模板注入漏洞的关键指示：

`Hello Carlos<tag>`

### 确认

一旦检测到模板注入潜力，下一步就是识别模板引擎。

尽管有大量的模板语言，但它们中的许多都使用非常相似的语法，这些语法是专门为不与 HTML 字符冲突而选择的。因此，创建探测有效负载以测试正在使用的模板引擎可能相对简单。

简单地提交无效语法通常就足够了，因为生成的错误消息会准确地告诉您模板引擎是什么，有时甚至是哪个版本。例如，无效表达式`<%=foobar%>`会触发来自基于 Ruby 的 ERB 引擎的以下响应：

``(erb):1:in `<main>': undefined local variable or method `foobar' for main:Object (NameError) from /usr/lib/ruby/2.5.0/erb.rb:876:in `eval' from /usr/lib/ruby/2.5.0/erb.rb:876:in `result' from -e:4:in `<main>'``

否则，您将需要手动测试不同语言特定的有效负载并研究模板引擎如何解释它们。使用基于哪些语法似乎有效或无效的排除过程，您可以比您想象的更快地缩小选项范围。这样做的一种常见方法是使用来自不同模板引擎的语法注入任意数学运算。然后，您可以观察它们是否被成功评估。为了帮助完成此过程，您可以使用类似于以下的决策树：

![[template-decision-tree.png]]

您应该知道，相同的有效负载有时会以一种以上的模板语言返回成功的响应。例如，有效负载在 Twig 和Jinja2 中`{{7*'7'}}`返回。因此，重要的是不要基于一个成功的响应就贸然下结论。 `49``7777777`

### 开发

在检测到存在潜在漏洞并成功识别模板引擎后，您可以开始尝试寻找利用它的方法。






## 如何防止服务器端模板注入漏洞

防止服务器端模板注入的最佳方法是不允许任何用户修改或提交新模板。但是，由于业务需求，这有时是不可避免的。

避免引入服务器端模板注入漏洞的最简单方法之一是始终使用“无逻辑”模板引擎，例如 Mustache，除非绝对必要。尽可能将逻辑与表示分离可以大大减少您面临最危险的基于模板的攻击。

另一种措施是仅在已完全删除潜在危险模块和功能的沙盒环境中执行用户代码。不幸的是，沙盒化不受信任的代码本质上是困难的并且容易被绕过。

最后，另一种补充方法是接受任意代码执行几乎是不可避免的，并通过将模板环境部署在锁定的 Docker 容器中来应用自己的沙盒。

