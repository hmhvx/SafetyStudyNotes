# 不安全的反序列化

**序列化**是将复杂数据结构（例如对象及其字段）转换为“更扁平”格式的过程，该格式可以作为顺序字节流发送和接收。序列化数据使以下操作变得更加简单：

-   将复杂数据写入进程间内存、文件或数据库
-   例如，通过网络、应用程序的不同组件之间或在 API 调用中发送复杂数据

至关重要的是，当序列化一个对象时，它的状态也是持久的。换句话说，对象的属性及其分配的值被保留。

**反序列化**是将此字节流恢复为原始对象的完整功能副本的过程，其状态与序列化时的状态完全相同。然后网站的逻辑可以与这个反序列化的对象进行交互，就像它与任何其他对象一样。

## PHP序列化格式

PHP 使用一种人类可读的字符串格式，其中字母代表数据类型，数字代表每个条目的长度。例如，考虑一个`User`具有以下属性的对象：

`$user->name = "carlos"; $user->isLoggedIn = true;`

序列化后，此对象可能如下所示：

`O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}`

这可以解释如下：

-   `O:4:"User"`- 具有 4 个字符的类名的对象`"User"`
-   `2`- 对象有 2 个属性
-   `s:4:"name"`- 第一个属性的key是4个字符的字符串`"name"`
-   `s:6:"carlos"`- 第一个属性的值是6个字符的字符串`"carlos"`
-   `s:10:"isLoggedIn"`- 第二个属性的key是10个字符的字符串`"isLoggedIn"`
-   `b:1`- 第二个属性的值是布尔值`true`

PHP 序列化的本机方法是`serialize()`和`unserialize()`. 如果您有源代码访问权限，则应首先`unserialize()`在代码中的任何位置查找并进一步调查。
## 操作序列化对象

利用一些反序列化漏洞可以像更改序列化对象中的属性一样简单。随着对象状态的持久化，您可以研究序列化数据以识别和编辑有趣的属性值。然后，您可以通过其反序列化过程将恶意对象传递到网站中。这是基本反序列化漏洞利用的初始步骤。

从广义上讲，在操作序列化对象时可以采用两种方法。您可以直接以字节流的形式编辑对象，也可以用相应的语言编写一个简短的脚本来自己创建和序列化新对象。使用二进制序列化格式时，后一种方法通常更容易。

### 修改对象属性

在篡改数据时，只要攻击者保留一个有效的序列化对象，反序列化过程就会创建一个带有修改后的属性值的服务器端对象。

举个简单的例子，考虑一个使用序列化`User`对象将用户会话数据存储在 cookie 中的网站。如果攻击者在 HTTP 请求中发现了这个序列化对象，他们可能会对其进行解码以找到以下字节流：

`O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}`

该`isAdmin`属性是一个明显的兴趣点。攻击者可以简单地将属性的布尔值更改为`1`(true)，重新编码对象，并用修改后的值覆盖他们当前的 cookie。单独来看，这没有任何效果。但是，假设网站使用此 cookie 来检查当前用户是否有权访问某些管理功能：

`$user = unserialize($_COOKIE); if ($user->isAdmin === true) { // allow access to admin interface }`

此易受攻击的代码将`User`根据 cookie 中的数据（包括攻击者修改的`isAdmin`属性）实例化一个对象。在任何时候都不会检查序列化对象的真实性。然后将此数据传递到条件语句中，在这种情况下，将允许轻松提升权限。

这种简单的场景在野外并不常见。但是，以这种方式编辑属性值展示了访问由不安全反序列化暴露的大量攻击面的第一步。


### 修改数据类型

我们已经了解了如何修改序列化对象中的属性值，但也可以提供意外的数据类型。

`==`基于 PHP 的逻辑在比较不同数据类型时 特别容易受到这种操作的影响，因为它的松散比较运算符 () 的行为。例如，如果您在整数和字符串之间执行松散比较，PHP 将尝试将字符串转换为整数，这意味着`5 == "5"`计算结果为`true`.

不同寻常的是，这也适用于任何以数字开头的字母数字字符串。在这种情况下，PHP 会根据初始数字有效地将整个字符串转换为整数值。字符串的其余部分被完全忽略。因此，`5 == "5 of something"` 在实践中被视为`5 == 5`。

当比较字符串整数时，这变得更加奇怪`0`：

`0 == "Example string" // true`

为什么？因为没有数字，即字符串中有0个数字。PHP 将整个字符串视为整数`0`。

考虑这种松散比较运算符与来自反序列化对象的用户可控数据结合使用的情况。这可能会导致危险的[逻辑缺陷](https://portswigger.net/web-security/logic-flaws)。

`$login = unserialize($_COOKIE) if ($login['password'] == $password) { // log in successfully }`

假设攻击者修改了密码属性，使其包含整数`0`而不是预期的字符串。只要存储的密码不以数字开头，条件就会始终返回`true`，从而启用身份验证绕过。请注意，这仅是可能的，因为反序列化保留了数据类型。如果代码直接从请求中获取密码，则`0`将被转换为字符串并且条件将评估为`false`.

请注意，在修改任何序列化对象格式的数据类型时，请务必记住更新序列化数据中的任何类型标签和长度指示符。否则，序列化的对象将被破坏，不会被反序列化。

## 使用应用程序功能

除了简单地检查属性值之外，网站的功能还可能对来自反序列化对象的数据执行危险操作。在这种情况下，您可以使用不安全的反序列化来传递意外数据并利用相关功能进行破坏。

例如，作为网站“删除用户”功能的一部分，通过访问`$user->image_location`属性中的文件路径来删除用户的个人资料图片。如果这`$user`是从序列化对象创建的，则攻击者可以通过将修改后的对象与`image_location`集合传递到任意文件路径来利用它。删除他们自己的用户帐户也会删除这个任意文件。

## 魔术方法

魔术方法是您不必显式调用的特殊方法子集。相反，只要发生特定事件或场景，就会自动调用它们。魔术方法是各种语言中面向对象编程的共同特征。它们有时通过用双下划线前缀或包围方法名称来表示。

开发人员可以为类添加魔术方法，以便预先确定在相应事件或场景发生时应该执行哪些代码。调用魔术方法的确切时间和原因因方法而异。PHP 中最常见的示例之一是`__construct()`，每当实例化类的对象时都会调用它，类似于 Python 的`__init__`. 通常，像这样的构造函数魔术方法包含初始化实例属性的代码。但是，开发人员可以自定义魔术方法来执行他们想要的任何代码。

魔术方法被广泛使用，它们本身并不代表漏洞。但是，当他们执行的代码处理攻击者可控制的数据时，例如来自反序列化对象的数据，他们可能会变得危险。攻击者可以利用这一点在满足相应条件时自动调用反序列化数据的方法。

**在这种情况下，最重要的是，一些语言具有在**反序列化过程中 自动调用的魔术方法。例如，PHP 的`unserialize()`方法查找并调用对象的`__wakeup()`魔法方法。

在 Java 反序列化中，同样适用于该`ObjectInputStream.readObject()`方法，该方法用于从初始字节流中读取数据，本质上类似于“重新初始化”序列化对象的构造函数。但是，`Serializable`类也可以声明自己的`readObject()`方法，如下所示：

`private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { // implementation }`

以这种`readObject()`方式声明的方法充当反序列化期间调用的魔术方法。这允许类更紧密地控制其自身字段的反序列化。

您应该密切注意包含这些类型的魔术方法的任何类。它们允许您在对象完全反序列化之前将数据从序列化对象传递到网站代码中。这是创建更高级漏洞利用的起点。

## 注入任意对象

正如我们所见，有时可以通过简单地编辑网站提供的对象来利用不安全的反序列化。但是，注入任意对象类型可以开辟更多可能性。

在面向对象编程中，对象可用的方法由其类决定。因此，如果攻击者可以操纵作为序列化数据传入的对象类，他们就可以影响在反序列化之后甚至在反序列化期间执行的代码。

反序列化方法通常不检查它们正在反序列化的内容。这意味着您可以传入网站可用的任何可序列化类的对象，并且该对象将被反序列化。这有效地允许攻击者创建任意类的实例。这个对象不属于预期的类这一事实并不重要。意外的对象类型可能会导致应用程序逻辑异常，但此时恶意对象已被实例化。

如果攻击者可以访问源代码，他们可以详细研究所有可用的类。为了构建一个简单的漏洞利用，他们会寻找包含反序列化魔术方法的类，然后检查它们中的任何一个是否对可控数据执行危险操作。然后，攻击者可以传入此类的序列化对象，以使用其魔术方法进行攻击。

## 小工具链

“小工具”是应用程序中存在的一段代码，可以帮助攻击者实现特定目标。单个小工具可能不会直接对用户输入做任何有害的事情。然而，攻击者的目标可能只是调用一个方法，将他们的输入传递给另一个小工具。通过以这种方式将多个小工具链接在一起，攻击者可能会将他们的输入传递到危险的“接收器小工具”中，从而造成最大的破坏。

重要的是要理解，与某些其他类型的漏洞利用不同，小工具链不是攻击者构造的链式方法的有效负载。所有代码已经存在于网站上。攻击者唯一控制的是传递到小工具链中的数据。这通常使用反序列化期间调用的魔术方法来完成，有时称为“启动小工具”。

在野外，许多不安全的反序列化漏洞只能通过使用小工具链来利用。这有时可能是一个简单的一步或两步链，但构建高严重性攻击可能需要更复杂的对象实例化和方法调用序列。因此，能够构建小工具链是成功利用不安全反序列化的关键方面之一。

### 使用预先构建的小工具链

手动识别小工具链可能是一个相当艰巨的过程，如果没有源代码访问几乎是不可能的。幸运的是，您可以先尝试一些使用预构建小工具链的选项。

有几种工具可提供一系列预先发现的链，这些链已在其他网站上成功利用。即使您无权访问源代码，也可以使用这些工具以相对较少的工作量来识别和利用不安全的反序列化漏洞。由于包含可利用小工具链的库的广泛使用，这种方法成为可能。例如，如果 Java 的 Apache Commons Collections 库中的小工具链可以在一个网站上被利用，那么实现该库的任何其他网站也可以使用相同的链来利用。

#### ysoserial

Java 反序列化的一种此类工具是“ysoserial”。这使您可以为您认为目标应用程序正在使用的库选择提供的小工具链之一，然后传入您要执行的命令。然后它根据所选链创建适当的序列化对象。这仍然需要一定的反复试验，但与手动构建自己的小工具链相比，它的劳动强度要低得多。

请注意，并非 ysoserial 中的所有小工具链都可以让您运行任意代码。相反，它们可能对其他目的有用。例如，您可以使用以下方法帮助您快速检测几乎任何服务器上的不安全反序列化：

-   该`URLDNS`链触发对提供的 URL 的 DNS 查找。最重要的是，它不依赖于使用特定易受攻击库的目标应用程序，并且可以在任何已知的 Java 版本中运行。这使其成为用于检测目的的最通用的小工具链。如果您在流量中发现了一个序列化对象，您可以尝试使用这个小工具链来生成一个触发与 Burp Collaborator 服务器的 DNS 交互的对象。如果是这样，您可以确定您的目标上发生了反序列化。
-   `JRMPClient`是另一个可用于初始检测的通用链。它使服务器尝试与提供的 IP 地址建立 TCP 连接。请注意，您需要提供原始 IP 地址而不是主机名。此链在所有出站流量都被防火墙保护的环境中可能很有用，包括 DNS 查找。您可以尝试使用两个不同的 IP 地址生成有效负载：一个本地地址和一个有防火墙的外部地址。如果应用程序立即响应具有本地地址的有效负载，但挂起具有外部地址的有效负载，导致响应延迟，这表明小工具链工作，因为服务器试图连接到防火墙地址。在这种情况下，响应的细微时间差异可以帮助您检测服务器上是否发生了反序列化，即使是在盲目情况下也是如此。

#### PHP 通用小工具链

大多数经常遭受不安全反序列化漏洞的语言都有等效的概念验证工具。例如，对于基于 PHP 的站点，您可以使用“PHP Generic Gadget Chains”（PHPGGC）。

#### 笔记

需要注意的是，该漏洞是用户可控数据的反序列化，而不仅仅是网站代码或其任何库中存在小工具链。小工具链只是在注入有害数据后操纵它的一种手段。这也适用于依赖于不受信任数据的反序列化的各种内存损坏漏洞。换句话说，即使网站确实设法堵塞了所有可能的小工具链，它仍然可能容易受到攻击。

### 使用记录在案的小工具链

在目标应用程序使用的框架中，可能并不总是有专门的工具可用于利用已知的小工具链。在这种情况下，总是值得在网上查看是否有任何记录在案的漏洞可以手动调整。调整代码可能需要对语言和框架有一些基本的了解，并且您有时可能需要自己序列化对象，但这种方法仍然比从头开始构建漏洞要少得多。

即使您找不到可以使用的小工具链，您仍然可以获得宝贵的知识，帮助您创建自己的自定义漏洞利用。

## 创建自己的漏洞利用

当现成的小工具链和记录的漏洞利用不成功时，您将需要创建自己的漏洞利用。

要成功构建您自己的小工具链，您几乎肯定需要访问源代码。第一步是研究此源代码以识别包含在反序列化期间调用的魔术方法的类。评估这个魔术方法执行的代码，看看它是否直接对用户可控属性做任何危险的事情。这总是值得检查以防万一。

如果魔术方法本身不可利用，它可以作为小工具链的“启动小工具”。研究启动小工具调用的任何方法。这些是否会对您控制的数据造成危险？如果没有，请仔细查看它们随后调用的每个方法，依此类推。

重复此过程，跟踪您可以访问哪些值，直到您到达死胡同或确定您的可控数据传递到的危险接收器小工具。

一旦您弄清楚如何在应用程序代码中成功构建小工具链，下一步就是创建一个包含您的有效负载的序列化对象。这只是一个研究源代码中的类声明并创建一个有效的序列化对象的案例，该对象具有您的漏洞利用所需的适当值。正如我们在之前的实验中所看到的，在使用基于字符串的序列化格式时，这相对简单。

使用二进制格式，例如在构建 Java 反序列化漏洞利用时，可能特别麻烦。在对现有对象进行细微更改时，您可能会很乐意直接使用字节。但是，当进行更重要的更改时，例如传入一个全新的对象，这很快就会变得不切实际。为了自己生成和序列化数据，用目标语言编写自己的代码通常要简单得多。

在创建自己的小工具链时，寻找机会利用这个额外的攻击面来触发次要漏洞。

通过仔细研究源代码，您可以发现更长的小工具链，这些小工具链可能允许您构建高严重性攻击，通常包括远程代码执行。


## PHAR 反序列化

到目前为止，我们主要研究了利用网站显式反序列化用户输入的反序列化漏洞。然而，在 PHP 中，即使没有明显使用该`unserialize()`方法，有时也可以利用反序列化。

PHP 提供了几个 URL 样式的包装器，您可以在访问文件路径时使用它们来处理不同的协议。其中之一是`phar://`包装器，它提供了用于访问 PHP Archive ( `.phar`) 文件的流接口。

PHP 文档显示`PHAR`清单文件包含序列化的元数据。至关重要的是，如果您对流执行任何文件系统操作`phar://` ，此元数据将被隐式反序列化。这意味着如果`phar://`您可以将此流传递给文件系统方法，则流可能是利用不安全反序列化的向量。

在明显危险的文件系统方法（例如`include()`或）的情况下`fopen()`，网站可能已经实施了反措施以减少它们被恶意使用的可能性。然而，诸如 的方法`file_exists()`并没有那么明显的危险，可能没有得到很好的保护。

此技术还要求您以某种方式将其上传`PHAR`到服务器。例如，一种方法是使用图像上传功能。如果您能够创建一个`PHAR`伪装成 simple的多语言文件，`JPG`您有时可以绕过网站的验证检查。如果您随后可以强制网站`JPG`从`phar://` 流中加载此多语言“”，则您通过元数据注入的任何有害数据都`PHAR`将被反序列化。由于 PHP 读取流时不检查文件扩展名，因此文件使用图像扩展名并不重要。

只要网站支持对象的类，就可以通过这种方式调用 the`__wakeup()`和`__destruct()`magic 方法，允许您使用这种技术潜在地启动小工具链。

这项创新技术出现在我们 2018 年的十大网络黑客技术中。

## 利用内存损坏利用反序列化

即使不使用小工具链，仍然有可能利用不安全的反序列化。如果所有其他方法都失败了，则通常有公开记录的内存损坏漏洞可以通过不安全的反序列化来利用。这些通常会导致远程代码执行。

反序列化方法（例如 PHP）`unserialize()`很少能抵御此类攻击，并暴露出大量的攻击面。这本身并不总是被认为是一个漏洞，因为这些方法最初并不是为了处理用户可控的输入。
## 如何防止不安全的反序列化漏洞

一般来说，除非绝对必要，否则应避免对用户输入进行反序列化。在许多情况下，它可能实现的高严重性漏洞利用以及防御漏洞利用的难度超过了收益。

如果您确实需要对来自不受信任来源的数据进行反序列化，请采用可靠的措施以确保数据未被篡改。例如，您可以实施数字签名来检查数据的完整性。但是，请记住，必须**在**开始反序列化过程之前进行任何检查。否则，它们几乎没有用处。

如果可能，您应该完全避免使用通用反序列化功能。这些方法的序列化数据包含原始对象的所有属性，包括可能包含敏感信息的私有字段。相反，您可以创建自己的特定于类的序列化方法，以便您至少可以控制公开哪些字段。

最后，请记住，漏洞是用户输入的反序列化，而不是随后处理数据的小工具链的存在。不要依赖于尝试消除您在测试期间识别的小工具链。由于几乎可以肯定您的网站上存在跨库依赖关系的网络，因此尝试将它们全部插入是不切实际的。在任何给定时间，公开记录的内存损坏漏洞也是一个因素，这意味着您的应用程序无论如何都可能容易受到攻击。