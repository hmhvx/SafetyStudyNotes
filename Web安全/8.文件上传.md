# 文件上传漏洞

文件上传漏洞是指 Web 服务器允许用户在没有充分验证文件名称、类型、内容或大小等内容的情况下将文件上传到其文件系统。未能正确执行这些限制可能意味着即使是基本的图像上传功能也可用于上传任意且具有潜在危险的文件。这甚至可以包括启用远程代码执行的服务器端脚本文件。


## 利用不受限制的文件上传来部署 web shell

从安全角度来看，最糟糕的情况是网站允许您上传服务器端脚本，例如 PHP、Java 或 Python 文件，并且还配置为将它们作为代码执行。这使得在服务器上创建自己的 web shell 变得很简单。
如果您能够成功上传 Web Shell，您就可以有效地完全控制服务器。这意味着您可以读取和写入任意文件、泄露敏感数据，甚至可以使用服务器对内部基础设施和网络外的其他服务器进行攻击。例如，下面的 PHP one-liner 可用于从服务器的文件系统中读取任意文件：

><?php echo file_get_contents('/path/to/target/file'); ?>

一个更通用的 web shell 可能看起来像这样：

><?php echo system($_GET['command']); ?>

此脚本使您能够通过查询参数传递任意系统命令，如下所示：

>GET /example/exploit.php?command=id HTTP/1.1

## 利用有缺陷的文件上传验证

在正常情况下，您不太可能找到一个网站，它对文件上传攻击没有任何保护，就像我们在之前的实验室中看到的那样。但仅仅因为防御措施到位，并不意味着它们是强大的。

### 有缺陷的文件类型验证

提交 HTML 表单时，浏览器通常会在`POST`请求中以 content type发送所提供的数据`application/x-www-form-url-encoded`。这适用于发送您的姓名、地址等简单文本，但不适用于发送大量二进制数据，例如整个图像文件或 PDF 文档。在这种情况下，内容类型`multipart/form-data`是首选方法。

考虑一个包含用于上传图像、提供图像描述和输入用户名的字段的表单。提交此类表单可能会导致请求如下所示：

>POST /images HTTP/1.1 
>Host: normal-website.com 
>Content-Length: 12345 
>Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456 ---------------------------012345678901234567890123456 Content-Disposition: form-data; name="image"; filename="example.jpg" 
>Content-Type: image/jpeg 
>[...binary content of example.jpg...] 
>---------------------------012345678901234567890123456 
>Content-Disposition: form-data; name="description"
> This is an interesting description of my image. ---------------------------012345678901234567890123456 
> Content-Disposition: form-data; name="username" 
> wiener ---------------------------012345678901234567890123456--`

如您所见，消息正文被拆分为每个表单输入的单独部分。每个部分都包含一个`Content-Disposition`标题，该标题提供了有关与其相关的输入字段的一些基本信息。这些单独的部分也可能包含它们自己的`Content-Type`标头，它告诉服务器使用此输入提交的数据的 MIME 类型。

网站可能尝试验证文件上传的一种方法是检查此特定于输入的`Content-Type`标头是否与预期的 MIME 类型匹配。例如，如果服务器只需要图像文件，它可能只允许`image/jpeg`和之类的类型`image/png`。当此标头的值被服务器隐式信任时，可能会出现问题。如果不执行进一步的验证来检查文件的内容是否实际匹配假定的 MIME 类型，则可以使用 Burp Repeater 等工具轻松绕过这种防御。

### 防止在用户可访问的目录中执行文件

作为预防措施，服务器通常只运行其类型已明确配置为执行的脚本。否则，它们可能只是返回某种错误消息，或者在某些情况下，将文件内容作为纯文本提供。
如果能找到一种方法将脚本上传到不应该包含用户提供的文件的不同目录，那么服务器最终可能会执行您的脚本

>Content-Disposition: form-data; name="avatar"; filename="../exploit.php"
>Content-Disposition: form-data; name="avatar"; filename="..%2fexploit.php"

## 危险文件类型的黑名单不足

### 覆盖服务器配置
服务器通常不会执行文件，除非它们已被配置为这样做。
在 Burp Repeater 中，转到`POST /my-account/avatar`请求的选项卡并找到与您的 PHP 文件相关的正文部分。进行以下更改：
    -   `filename`将参数 的值更改为`.htaccess`。
    -   `Content-Type`将标头 的值更改为`text/plain`.
    -   将文件的内容（您的 PHP 有效负载）替换为以下 Apache 指令：
        
        `AddType application/x-httpd-php .l33t`
        
这会将任意扩展名 ( `.l33t`) 映射到可执行 MIME 类型`application/x-httpd-php`。由于服务器使用该`mod_php`模块，它已经知道如何处理这个问题。

 `filename`将参数 的值从 更改`exploit.php`为`exploit.l33t`。再次发送请求，发现文件上传成功。

### 混淆文件扩展名

即使是最详尽的黑名单也可能被经典的混淆技术绕过。假设验证代码区分大小写并且无法识别它`exploit.pHp`实际上是一个`.php`文件。如果随后将文件扩展名映射到 MIME 类型的代码**不**区分大小写，则这种差异允许您将恶意 PHP 文件偷偷通过验证，最终可能由服务器执行。

您还可以使用以下技术获得类似的结果：

-   提供多个扩展。根据用于解析文件名的算法，以下文件可能被解释为 PHP 文件或 JPG 图像：`exploit.php.jpg`
-   添加尾随字符。一些组件会去除或忽略尾随空格、点等：`exploit.php.`
-   尝试对点、正斜杠和反斜杠使用 URL 编码（或双 URL 编码）。如果在验证文件扩展名时该值没有被解码，但后来在服务器端被解码，这也可以让您上传否则会被阻止的恶意文件：`exploit%2Ephp`
-   在文件扩展名前添加分号或 URL 编码的空字节字符。如果验证是用 PHP 或 Java 等高级语言编写的，但服务器使用 C/C++ 中的低级函数处理文件，例如，这可能会导致文件名结尾出现差异：`exploit.asp;.jpg`或`exploit.asp%00.jpg`
-   尝试使用多字节 unicode 字符，在 unicode 转换或规范化后可能会转换为空字节和点。`xC0 x2E`如果文件名被解析为 UTF-8 字符串，则类似`xC4 xAE`或的序列`xC0 xAE`可能会被转换为`x2E`，但随后会在用于路径之前转换为 ASCII 字符。

## 有缺陷的文件内容验证

安全的服务器不会隐式信任`Content-Type`请求中指定的内容，而是尝试验证文件的内容是否与预期内容相符。

在图像上传功能的情况下，服务器可能会尝试验证图像的某些内在属性，例如其尺寸。例如，如果您尝试上传 PHP 脚本，则它根本没有任何维度。因此，服务器可以推断它不可能是图像，并相应地拒绝上传。

同样，某些文件类型可能总是在其页眉或页脚中包含特定的字节序列。这些可以用作指纹或签名来确定内容是否与预期类型匹配。例如，JPEG 文件总是以 bytes 开头`FF D8 FF`。

这是一种更可靠的文件类型验证方法，但即使这样也不是万无一失的。使用 ExifTool 等特殊工具，可以轻松创建包含元数据中恶意代码的多语言 JPEG 文件。

## 利用文件上传竞争条件

现代框架更能抵御此类攻击。他们通常不会将文件直接上传到文件系统上的预期目的地。相反，他们采取了预防措施，例如首先上传到临时的沙盒目录并随机命名以避免覆盖现有文件。然后，他们对这个临时文件执行验证，并且只有在认为安全的情况下才将其传输到目的地。

也就是说，开发人员有时会独立于任何框架来实现自己的文件上传处理。做好这件事不仅相当复杂，而且还可能引入危险的竞争条件，使攻击者能够完全绕过最强大的验证。

例如，一些网站将文件直接上传到主文件系统，如果没有通过验证，则再次将其删除。这种行为在依赖防病毒软件等检查恶意软件的网站中很常见。这可能只需要几毫秒，但在文件存在于服务器上的短时间内，攻击者仍有可能执行它。

这些漏洞通常非常微妙，因此在黑盒测试期间很难检测到，除非您能找到泄漏相关源代码的方法。

## 使用 PUT 上传文件

值得注意的是，某些 Web 服务器可能被配置为支持`PUT`请求。如果没有适当的防御措施，这可以提供一种上传恶意文件的替代方法，即使上传功能无法通过 Web 界面使用。

>PUT /images/exploit.php HTTP/1.1 
>Host: vulnerable-website.com 
>Content-Type: application/x-httpd-php Content-Length: 49 
><?php echo file_get_contents('/path/to/file'); ?>